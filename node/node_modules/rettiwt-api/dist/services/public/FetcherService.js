"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetcherService = void 0;
const axios_1 = __importDefault(require("axios"));
const cookiejar_1 = require("cookiejar");
const Groups_1 = require("../../collections/Groups");
const Requests_1 = require("../../collections/Requests");
const Api_1 = require("../../enums/Api");
const Logging_1 = require("../../enums/Logging");
const FetchArgs_1 = require("../../models/args/FetchArgs");
const PostArgs_1 = require("../../models/args/PostArgs");
const AuthCredential_1 = require("../../models/auth/AuthCredential");
const AuthService_1 = require("../internal/AuthService");
const ErrorService_1 = require("../internal/ErrorService");
const LogService_1 = require("../internal/LogService");
const TidService_1 = require("../internal/TidService");
/**
 * The base service that handles all HTTP requests.
 *
 * @public
 */
class FetcherService {
    /** The AuthService instance to use. */
    _auth;
    /** The delay/delay function to use (ms). */
    _delay;
    /** The service used to handle HTTP and API errors */
    _errorHandler;
    /** Service responsible for generating the `x-client-transaction-id` header. */
    _tidProvider;
    /** The max wait time for a response. */
    _timeout;
    /** The config object. */
    config;
    /**
     * @param config - The config object for configuring the Rettiwt instance.
     */
    constructor(config) {
        LogService_1.LogService.enabled = config.logging ?? false;
        this.config = config;
        this._delay = config.delay;
        this._errorHandler = config.errorHandler ?? new ErrorService_1.ErrorService();
        this._tidProvider = config.tidProvider ?? new TidService_1.TidService(config);
        this._timeout = config.timeout ?? 0;
        this._auth = new AuthService_1.AuthService(config);
    }
    /**
     * Checks the authorization status based on the requested resource.
     *
     * @param resource - The requested resource.
     *
     * @throws An error if not authorized to access the requested resource.
     */
    checkAuthorization(resource) {
        // Logging
        LogService_1.LogService.log(Logging_1.ELogActions.AUTHORIZATION, { authenticated: this.config.userId != undefined });
        // Checking authorization status
        if (!Groups_1.allowGuestAuthentication.includes(resource) && this.config.userId == undefined) {
            throw new Error(Api_1.EApiErrors.RESOURCE_NOT_ALLOWED);
        }
    }
    /**
     * Returns the AuthCredentials based on the type of key present.
     *
     * @returns The generated AuthCredential
     */
    async getCredential() {
        if (this.config.apiKey) {
            // Logging
            LogService_1.LogService.log(Logging_1.ELogActions.GET, { target: 'USER_CREDENTIAL' });
            return new AuthCredential_1.AuthCredential(AuthService_1.AuthService.decodeCookie(this.config.apiKey)
                .split(';')
                .map((item) => new cookiejar_1.Cookie(item)));
        }
        else {
            // Logging
            LogService_1.LogService.log(Logging_1.ELogActions.GET, { target: 'NEW_GUEST_CREDENTIAL' });
            return this._auth.guest();
        }
    }
    /**
     * Generates the header for the transaction ID.
     *
     * @param method - The target method.
     * @param url - The target URL.
     *
     * @returns The header containing the transaction ID.
     */
    async getTransactionHeader(method, url) {
        // Getting the URL path excluding all params
        const path = new URL(url).pathname.split('?')[0].trim();
        // Generating the transaction ID
        const tid = await this._tidProvider.generate(method.toUpperCase(), path);
        if (tid) {
            return {
                /* eslint-disable @typescript-eslint/naming-convention */
                'x-client-transaction-id': tid,
                /* eslint-enable @typescript-eslint/naming-convention */
            };
        }
        else {
            return undefined;
        }
    }
    /**
     * Validates the given args against the given resource.
     *
     * @param resource - The resource against which validation is to be done.
     * @param args - The args to be validated.
     *
     * @returns The validated args.
     */
    validateArgs(resource, args) {
        if (Groups_1.fetchResources.includes(resource)) {
            // Logging
            LogService_1.LogService.log(Logging_1.ELogActions.VALIDATE, { target: 'FETCH_ARGS' });
            return new FetchArgs_1.FetchArgs(resource, args);
        }
        else if (Groups_1.postResources.includes(resource)) {
            // Logging
            LogService_1.LogService.log(Logging_1.ELogActions.VALIDATE, { target: 'POST_ARGS' });
            return new PostArgs_1.PostArgs(resource, args);
        }
    }
    /**
     * Introduces a delay using the configured delay/delay function.
     */
    async wait() {
        // If no delay is set, skip
        if (this._delay == undefined) {
            return;
        }
        /** The delay (in ms) to use. */
        let delay = 0;
        // Getting the delay
        if (this._delay && typeof this._delay == 'number') {
            delay = this._delay;
        }
        else if (this._delay && typeof this._delay == 'function') {
            delay = await this._delay();
        }
        // Awaiting for the delay time
        await new Promise((resolve) => setTimeout(resolve, delay));
    }
    /**
     * Makes an HTTP request according to the given parameters.
     *
     * @param resource - The requested resource.
     * @param config - The request configuration.
     *
     * @typeParam T - The type of the returned response data.
     *
     * @returns The raw data response received.
     *
     * @example
     * Fetching the raw details of a user with username 'user1'
     * ```
     * import { FetcherService, EResourceType } from 'rettiwt-api';
     *
     * // Creating a new FetcherService instance using the given 'API_KEY'
     * const fetcher = new FetcherService({ apiKey: API_KEY });
     *
     * // Fetching the details of the User with username 'user1'
     * fetcher.request(EResourceType.USER_DETAILS_BY_USERNAME, { id: 'user1' })
     * .then(res => {
     * 	console.log(res);
     * })
     * .catch(err => {
     * 	console.log(err);
     * })
     * ```
     */
    async request(resource, args) {
        // Logging
        LogService_1.LogService.log(Logging_1.ELogActions.REQUEST, { resource: resource, args: args });
        // Checking authorization for the requested resource
        this.checkAuthorization(resource);
        // Validating args
        args = this.validateArgs(resource, args);
        // Getting credentials from key
        const cred = await this.getCredential();
        // Getting request configuration
        const config = Requests_1.requests[resource](args);
        // Setting additional request parameters
        config.headers = {
            ...config.headers,
            ...cred.toHeader(),
            ...(await this.getTransactionHeader(config.method ?? '', config.url ?? '')),
            ...this.config.headers,
        };
        config.httpAgent = this.config.httpsAgent;
        config.httpsAgent = this.config.httpsAgent;
        config.timeout = this._timeout;
        // Sending the request
        try {
            // Introducing a delay
            await this.wait();
            // Returning the reponse body
            return (await (0, axios_1.default)(config)).data;
        }
        catch (error) {
            // If error, delegate handling to error handler
            this._errorHandler.handle(error);
            throw error;
        }
    }
}
exports.FetcherService = FetcherService;
//# sourceMappingURL=FetcherService.js.map